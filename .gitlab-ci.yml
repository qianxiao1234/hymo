stages:
  - build
  - release

variables:
  GIT_SUBMODULE_STRATEGY: recursive
  ANDROID_NDK_VERSION: "r25c"
  NODE_VERSION: "20"

# ÁºìÂ≠òÈÖçÁΩÆ
.cache_template: &cache_config
  cache:
    key:
      files:
        - webui/package-lock.json
    paths:
      - webui/node_modules/
      - .ndk-cache/

# ÊûÑÂª∫‰ªªÂä°ÔºàÊØèÊ¨°Êé®ÈÄÅÈô§ tag Â§ñËß¶ÂèëÔºâ
build:
  stage: build
  image: ubuntu:24.04
  <<: *cache_config
  rules:
    - if: $CI_COMMIT_TAG
      when: never
    - if: $CI_COMMIT_MESSAGE =~ /\[skip ci\]/
      when: never
    - if: $CI_PIPELINE_SOURCE == "web"
    - if: $CI_COMMIT_BRANCH
      changes:
        compare_to: 'refs/heads/master'
        paths:
          - "**/*"
    - when: on_success

  before_script:
    - apt-get update
    - apt-get install -y wget unzip git cmake ninja-build curl python3 python3-pip openssl gnupg
    
    # Setup Node.js
    - curl -fsSL https://deb.nodesource.com/setup_${NODE_VERSION}.x | bash -
    - apt-get install -y nodejs
    
    # Setup Android NDK (ÁºìÂ≠ò‰ºòÂåñ)
    - |
      NDK_DIR="${CI_PROJECT_DIR}/.ndk-cache/android-ndk-${ANDROID_NDK_VERSION}"
      if [ ! -d "$NDK_DIR" ]; then
        echo "Downloading Android NDK ${ANDROID_NDK_VERSION}..."
        mkdir -p .ndk-cache
        cd .ndk-cache
        wget -q https://dl.google.com/android/repository/android-ndk-${ANDROID_NDK_VERSION}-linux.zip
        unzip -q android-ndk-${ANDROID_NDK_VERSION}-linux.zip
        rm android-ndk-${ANDROID_NDK_VERSION}-linux.zip
        cd ..
      fi
      export ANDROID_NDK="$NDK_DIR"
      export NDK_PATH="$NDK_DIR"
      echo "NDK Path: $ANDROID_NDK"

  script:
    # Extract version
    - VERSION=$(grep "^version=" module/module.prop | cut -d= -f2)
    - echo "MODULE_VERSION=$VERSION" >> build.env
    - echo "Building version|$VERSION"
    
    # Install WebUI dependencies
    - cd webui && npm install && cd ..
    
    # Build project
    - ./build.sh init
    - ./build.sh package
    
    # Rename output with hash
    - COMMIT_HASH=$(git rev-parse --short HEAD)
    - echo "Adding commit hash $COMMIT_HASH to artifacts..."
    - cd build/out
    - |
      for file in *.zip; do
        mv "$file" "${file%.zip}-$COMMIT_HASH.zip"
      done
    - cd ../..
    
    # Sign module (internal) - ‰ªÖÁâπÂÆöÁî®Êà∑
    - |
      if [ "$GITLAB_USER_LOGIN" == "Anatdx" ] && [ -n "$MODULE_PRIVATE_KEY" ]; then
        echo "üîê Found private key, performing internal signing..."
        pip3 install cryptography
        
        # Support both File variable and Base64 encoded variable
        if [ -f "$MODULE_PRIVATE_KEY" ]; then
          # File type variable (recommended)
          cp "$MODULE_PRIVATE_KEY" private.pem
        elif echo "$MODULE_PRIVATE_KEY" | base64 -d > /dev/null 2>&1; then
          # Base64 encoded variable
          echo "$MODULE_PRIVATE_KEY" | base64 -d > private.pem
        else
          # Plain text variable (direct content)
          echo "$MODULE_PRIVATE_KEY" > private.pem
        fi
        
        openssl req -new -x509 -key private.pem -out certificate.pem -days 10000 \
          -subj "/C=CN/ST=Hymo/L=Hymo/O=Hymo/OU=Hymo/CN=Hymo Module"
        ZIP_FILE=$(ls build/out/*.zip | head -n 1)
        echo "Signing $ZIP_FILE..."
        python3 script/sign_zip.py "$ZIP_FILE" "build/out/signed.zip" private.pem certificate.pem
        mv "build/out/signed.zip" "$ZIP_FILE"
        rm private.pem certificate.pem
        echo "‚úÖ Internal signing complete."
      fi
    
    # GPG signing - ‰ªÖÁâπÂÆöÁî®Êà∑
    - |
      if [ "$GITLAB_USER_LOGIN" == "Anatdx" ] && [ -n "$GPG_PRIVATE_KEY" ]; then
        echo "üîê Performing GPG signing..."
        
        # Support both File variable and Base64 encoded variable
        if [ -f "$GPG_PRIVATE_KEY" ]; then
          gpg --import --batch "$GPG_PRIVATE_KEY"
        elif echo "$GPG_PRIVATE_KEY" | base64 -d > /dev/null 2>&1; then
          echo "$GPG_PRIVATE_KEY" | base64 -d | gpg --import --batch
        else
          echo "$GPG_PRIVATE_KEY" | gpg --import --batch
        fi
        cd build/out
        ZIP_FILE=$(ls *.zip | head -n 1)
        echo "Signing $ZIP_FILE with GPG..."
        echo "$GPG_PASSPHRASE" | gpg --detach-sign --local-user an@anatdx.com \
          --batch --yes --pinentry-mode loopback --passphrase-fd 0 \
          --output "$ZIP_FILE.asc" "$ZIP_FILE"
        if [ -f "$ZIP_FILE.asc" ]; then
          echo "‚úÖ GPG signature created successfully"
          ls -lh "$ZIP_FILE.asc"
        fi
        cd ../..
      fi

  artifacts:
    name: "Hymo-${VERSION}-${CI_COMMIT_SHORT_SHA}"
    paths:
      - build/out/*.zip
      - build/out/*.zip.asc
    reports:
      dotenv: build.env
    expire_in: 7 days

  after_script:
    # Upload to Telegram
    - |
      if [ -n "$TELEGRAM_BOT_TOKEN" ]; then
        echo "üì§ Ê≠£Âú®‰∏ä‰º†Âà∞Telegram..."
        pip3 install telethon
        python3 script/buildbot.py build/out/*.zip || true
        echo "‚úÖ Êñá‰ª∂Â∑≤‰∏ä‰º†Âà∞Telegram"
      fi

# ÂèëÂ∏É‰ªªÂä°Ôºà‰ªÖÊ†áÁ≠æËß¶ÂèëÔºâ
release:
  stage: release
  image: ubuntu:24.04
  <<: *cache_config
  rules:
    - if: $CI_COMMIT_TAG =~ /^v\d+\.\d+\.\d+$/

  before_script:
    - apt-get update
    - apt-get install -y wget unzip git cmake ninja-build curl python3 python3-pip openssl gnupg jq
    
    # Setup Node.js
    - curl -fsSL https://deb.nodesource.com/setup_${NODE_VERSION}.x | bash -
    - apt-get install -y nodejs
    
    # Setup Android NDK
    - |
      NDK_DIR="${CI_PROJECT_DIR}/.ndk-cache/android-ndk-${ANDROID_NDK_VERSION}"
      if [ ! -d "$NDK_DIR" ]; then
        echo "Downloading Android NDK ${ANDROID_NDK_VERSION}..."
        mkdir -p .ndk-cache
        cd .ndk-cache
        wget -q https://dl.google.com/android/repository/android-ndk-${ANDROID_NDK_VERSION}-linux.zip
        unzip -q android-ndk-${ANDROID_NDK_VERSION}-linux.zip
        rm android-ndk-${ANDROID_NDK_VERSION}-linux.zip
        cd ..
      fi
      export ANDROID_NDK="$NDK_DIR"
      export NDK_PATH="$NDK_DIR"

  script:
    # Update module version
    - PROP_FILE="module/module.prop"
    - TAG_NAME="$CI_COMMIT_TAG"
    - RUN_NUMBER="$CI_PIPELINE_IID"
    - echo "Updating module.prop info..."
    - echo "  Version -> $TAG_NAME"
    - echo "  VersionCode -> $RUN_NUMBER"
    - sed -i "s/^version=.*/version=$TAG_NAME/" "$PROP_FILE"
    - sed -i "s/^versionCode=.*/versionCode=$RUN_NUMBER/" "$PROP_FILE"
    - cat "$PROP_FILE"
    
    # Install WebUI dependencies
    - cd webui && npm install && cd ..
    
    # Build project
    - ./build.sh init
    - ./build.sh package
    
    # Sign module (internal)
    - |
      if [ -n "$MODULE_PRIVATE_KEY" ]; then
        echo "üîê Found private key, performing internal signing..."
        pip3 install cryptography
        
        # Support both File variable and Base64 encoded variable
        if [ -f "$MODULE_PRIVATE_KEY" ]; then
          # File type variable (recommended)
          cp "$MODULE_PRIVATE_KEY" private.pem
        elif echo "$MODULE_PRIVATE_KEY" | base64 -d > /dev/null 2>&1; then
          # Base64 encoded variable
          echo "$MODULE_PRIVATE_KEY" | base64 -d > private.pem
        else
          # Plain text variable (direct content)
          echo "$MODULE_PRIVATE_KEY" > private.pem
        fi
        
        openssl req -new -x509 -key private.pem -out certificate.pem -days 10000 \
          -subj "/C=CN/ST=Hymo/L=Hymo/O=Hymo/OU=Hymo/CN=Hymo Module"
        
        # Support both File variable and Base64 encoded variable
        if [ -f "$GPG_PRIVATE_KEY" ]; then
          gpg --import --batch "$GPG_PRIVATE_KEY"
        elif echo "$GPG_PRIVATE_KEY" | base64 -d > /dev/null 2>&1; then
          echo "$GPG_PRIVATE_KEY" | base64 -d | gpg --import --batch
        else
          echo "$GPG_PRIVATE_KEY" | gpg --import --batch
        fi
        echo "Signing $ZIP_FILE..."
        python3 script/sign_zip.py "$ZIP_FILE" "build/out/signed.zip" private.pem certificate.pem
        mv "build/out/signed.zip" "$ZIP_FILE"
        rm private.pem certificate.pem
        echo "‚úÖ Internal signing complete."
      fi
    
    # Import and sign with GPG
    - |
      if [ -n "$GPG_PRIVATE_KEY" ]; then
        echo "üîê Performing GPG signing..."
        echo "$GPG_PRIVATE_KEY" | gpg --import --batch
        # ËÆæÁΩÆ‰ø°‰ªªÁ∫ßÂà´
        echo "D2640E18540E138974BC0669942F2C75D1DC540F:6:" | gpg --import-ownertrust
        cd build/out
        ZIP_FILE=$(ls *.zip | head -n 1)
        echo "Signing $ZIP_FILE with GPG..."
        echo "$GPG_PASSPHRASE" | gpg --detach-sign --local-user an@anatdx.com \
          --batch --yes --pinentry-mode loopback --passphrase-fd 0 \
          --output "$ZIP_FILE.asc" "$ZIP_FILE"
        if [ -f "$ZIP_FILE.asc" ]; then
          echo "‚úÖ GPG signature created successfully"
          ls -lh "$ZIP_FILE.asc"
        else
          echo "‚ùå Error: Signature file not created!"
          exit 1
        fi
        cd ../..
      fi
    
    # Generate update files
    - cp "$PROP_FILE" /tmp/module.prop
    - VERSION=$(grep "^version=" "$PROP_FILE" | cut -d= -f2)
    - VERSION_CODE=$(grep "^versionCode=" "$PROP_FILE" | cut -d= -f2)
    - ZIP_FILE=$(cd build/out && ls *.zip | head -n 1)
    - REPO="$CI_PROJECT_PATH"
    - TAG="$CI_COMMIT_TAG"
    - DOWNLOAD_URL="${CI_PROJECT_URL}/-/releases/${TAG}/downloads/${ZIP_FILE}"
    - CHANGELOG_URL="${CI_PROJECT_URL}/-/raw/master/changelog.md"
    - echo "Final Version:|$VERSION"
    - echo "Final Code:|$VERSION_CODE"
    - echo "Zip:|$ZIP_FILE"
    
    # Create update.json
    - |
      cat <<EOF > /tmp/update.json
      {
        "version": "$VERSION",
        "versionCode": $VERSION_CODE,
        "zipUrl": "$DOWNLOAD_URL",
        "changelog": "$CHANGELOG_URL"
      }
      EOF
    
    # Generate changelog
    - PREV_TAG=$(git describe --tags --abbrev=0 HEAD^ 2>/dev/null || echo "")
    - echo "## $VERSION" > /tmp/changelog.md
    - echo "" >> /tmp/changelog.md
    - |
      if [ -z "$PREV_TAG" ]; then
        echo "Initial release." >> /tmp/changelog.md
        git log --pretty=format:"* %s" >> /tmp/changelog.md
      else
        echo "Changes since $PREV_TAG:" >> /tmp/changelog.md
        git log --pretty=format:"* %s" "$PREV_TAG..HEAD" >> /tmp/changelog.md
      fi
    - cat /tmp/update.json
    - cat /tmp/changelog.md
    
    # Push update info to master
    - git config --global user.name "gitlab-ci"
    - git config --global user.email "gitlab-ci@gitlab.com"
    - git reset --hard
    - git fetch origin master
    - git checkout master
    - mv /tmp/update.json update.json
    - mv /tmp/changelog.md changelog.md
    - mv /tmp/module.prop module/module.prop
    - git add update.json changelog.md module/module.prop
    - |
      if ! git diff --staged --quiet; then
        git commit -m "[skip ci] Update info for $CI_COMMIT_TAG"
        git push "https://oauth2:${CI_PUSH_TOKEN}@${CI_SERVER_HOST}/${CI_PROJECT_PATH}.git" HEAD:master
      fi

  release:
    tag_name: $CI_COMMIT_TAG
    description: /tmp/changelog.md
    assets:
      links:
        - name: "${ZIP_FILE}"
          url: "${CI_PROJECT_URL}/-/jobs/artifacts/${CI_COMMIT_TAG}/raw/build/out/${ZIP_FILE}?job=release"
        - name: "${ZIP_FILE}.asc"
          url: "${CI_PROJECT_URL}/-/jobs/artifacts/${CI_COMMIT_TAG}/raw/build/out/${ZIP_FILE}.asc?job=release"

  artifacts:
    name: "Hymo-Release-${CI_COMMIT_TAG}"
    paths:
      - build/out/*.zip
      - build/out/*.zip.asc
    expire_in: never

  after_script:
    # Upload to Telegram
    - |
      if [ -n "$TELEGRAM_BOT_TOKEN" ]; then
        echo "üì§ Ê≠£Âú®‰∏ä‰º†Âà∞Telegram..."
        pip3 install telethon
        UPDATE_TEXT=$(cat /tmp/changelog.md | sed '1d' | sed '/^$/d')
        export MODULE_VER="$CI_COMMIT_TAG"
        export UPDATE="$UPDATE_TEXT"
        python3 script/buildbot.py build/out/*.zip || true
        echo "‚úÖ Êñá‰ª∂Â∑≤‰∏ä‰º†Âà∞Telegram"
      fi
